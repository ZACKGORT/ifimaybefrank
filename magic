<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SDF Lens Blur â€” Inline (No-derivatives)</title>
  <script>document.documentElement.className="js";</script>
  <style>
*,
*::after,
*::before { box-sizing: border-box; }

:root{
  font-size:12px;
  --color-text:#ffffff;
  --color-bg:#fff;
  --color-link:#898989;
  --color-link-hover:#fff;
  --page-padding:1.5rem;
}

body{
  margin:0;
  color:var(--color-text);
  background:var(--color-bg);
  font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
}

.js canvas{ position:fixed; top:0; left:0; }

.js .loading::before,
.js .loading::after{
  content:'';
  position:fixed;
  z-index:1000;
}
.js .loading::before{ inset:0; background:var(--color-bg); }
.js .loading::after{
  top:50%; left:50%; width:60px; height:60px; margin:-30px 0 0 -30px;
  border-radius:50%; opacity:.4; background:var(--color-link);
  animation:loaderAnim .7s linear infinite alternate forwards;
}
@keyframes loaderAnim{ to{ opacity:1; transform:scale3d(.5,.5,1);} }

a{ text-decoration:none; color:var(--color-link); outline:none; cursor:pointer; }
a:hover{ text-decoration:underline; color:var(--color-link-hover); }

.frame{
  text-transform:uppercase;
  padding:var(--page-padding);
  position:relative;
  display:grid;
  z-index:1000;
  width:100%;
  height:100%;
  grid-row-gap:1rem; grid-column-gap:2rem;
  pointer-events:none;
  justify-items:start;
  grid-template-columns:auto auto;
  grid-template-areas:'title' 'back' 'archive' 'github' 'sponsor' 'demos' 'tags';
}
.frame a{ pointer-events:auto; }
.frame__title{ grid-area:title; margin:0; color:#fff; }
.frame__back{ grid-area:back; }
.frame__archive{ grid-area:archive; }
.frame__github{ grid-area:github; }
.frame__tags{ grid-area:tags; display:flex; flex-wrap:wrap; gap:1rem; }
.frame__demos{ grid-area:demos; display:flex; gap:1rem; margin-right:1em; }
.frame__demos span{ opacity:.8; }
.frame__demos a.selected{ font-weight:bold; color:var(--color-link-hover); }

@media (min-width:53em){
  body{ --page-padding:2rem 3rem; }
  .frame{
    position:fixed; inset:0;
    grid-template-columns:auto auto auto auto 1fr;
    grid-template-rows:auto auto;
    align-content:space-between;
    grid-template-areas:'title back github archive sponsor' 'tags tags demos demos demos';
  }
}
  </style>
</head>
<body class="loading">
  <canvas id="gl"></canvas>

  <main id="app">
    <header class="frame">
      <h1 class="frame__title">SDF Lens Blur</h1>
      <a class="frame__back" href="?">Reload</a>
      <a class="frame__archive" href="https://tympanus.net/codrops/demos/" target="_blank" rel="noopener">All demos</a>
      <a class="frame__github" href="https://github.com/guilanier/codrops-sdf-lensblur" target="_blank" rel="noopener">GitHub</a>
      <nav class="frame__tags">
        <a href="https://tympanus.net/codrops/demos/?tag=scroll" target="_blank" rel="noopener">#webgl</a>
        <a href="https://tympanus.net/codrops/demos/?tag=three-js" target="_blank" rel="noopener">#three.js</a>
        <a href="https://tympanus.net/codrops/demos/?tag=webgl" target="_blank" rel="noopener">#shader</a>
      </nav>
      <nav class="frame__demos">
        <span>Variations:</span>
        <a data-var="0" href="?var=0">1</a>
        <a data-var="1" href="?var=1">2</a>
        <a data-var="2" href="?var=2">3</a>
        <a data-var="3" href="?var=3">4</a>
      </nav>
    </header>
  </main>

  <!-- FRAGMENT SHADER (no derivatives) -->
  <script id="frag" type="x-shader/x-fragment">
#ifdef GL_ES
precision mediump float;
precision mediump int;
#endif

varying vec2 v_texcoord;

uniform vec2 u_mouse;
uniform vec2 u_resolution;
uniform float u_pixelRatio;

/* constants */
#ifndef PI
#define PI 3.1415926535897932384626433832795
#endif
#ifndef TWO_PI
#define TWO_PI 6.2831853071795864769252867665590
#endif

#ifndef VAR
#define VAR 0
#endif

/* coords */
vec2 coord(in vec2 p) {
    p = p / u_resolution.xy;
    if (u_resolution.x > u_resolution.y) {
        p.x *= u_resolution.x / u_resolution.y;
        p.x += (u_resolution.y - u_resolution.x) / u_resolution.y / 2.0;
    } else {
        p.y *= u_resolution.y / u_resolution.x;
        p.y += (u_resolution.x - u_resolution.y) / u_resolution.x / 2.0;
    }
    p -= 0.5;
    p *= vec2(-1.0, 1.0);
    return p;
}
#define st0 coord(gl_FragCoord.xy)
#define mx  coord(u_mouse * u_pixelRatio)

/* SDFs */
float sdRoundRect(vec2 p, vec2 b, float r) {
    vec2 d = abs(p - 0.5) * 4.2 - b + vec2(r);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;
}
float sdCircle(in vec2 st, in vec2 center) {
    return length(st - center) * 2.0;
}
float sdPoly(in vec2 p, in float w, in int sides) {
    float a = atan(p.x, p.y) + PI;
    float r = TWO_PI / float(sides);
    float d = cos(floor(0.5 + a / r) * r - a) * length(max(abs(p) * 1.0, 0.0));
    return d * 2.0 - w;
}

/* Derivative-free AA step (approx) */
float aastep(float threshold, float value) {
    float afwidth = 1.5 / min(u_resolution.x, u_resolution.y); // px-based feather
    return smoothstep(threshold - afwidth, threshold + afwidth, value);
}

float fill(in float x) { return 1.0 - aastep(0.0, x); }
float fill(float x, float size, float edge) {
    return 1.0 - smoothstep(size - edge, size + edge, x);
}

float stroke(in float d, in float t) { return (1.0 - aastep(t, abs(d))); }
float stroke(float x, float size, float w, float edge) {
    float d = smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5);
    return clamp(d, 0.0, 1.0);
}

void main() {
    vec2 st = st0 + 0.5;
    vec2 posMouse = mx * vec2(1., -1.) + 0.5;

    float size = 1.2;
    float roundness = 0.4;
    float borderSize = 0.05;

    float circleSize = 0.3;
    float circleEdge = 0.5;

    float sdfCircle = fill(sdCircle(st, posMouse), circleSize, circleEdge);

    float sdf;
    if (VAR == 0) {
        sdf = sdRoundRect(st, vec2(size), roundness);
        sdf = stroke(sdf, 0.0, borderSize, sdfCircle) * 4.0;
    } else if (VAR == 1) {
        sdf = sdCircle(st, vec2(0.5));
        sdf = fill(sdf, 0.6, sdfCircle) * 1.2;
    } else if (VAR == 2) {
        sdf = sdCircle(st, vec2(0.5));
        sdf = stroke(sdf, 0.58, 0.02, sdfCircle) * 4.0;
    } else if (VAR == 3) {
        sdf = sdPoly(st - vec2(0.5, 0.45), 0.3, 3);
        sdf = fill(sdf, 0.05, sdfCircle) * 1.4;
    }

    gl_FragColor = vec4(vec3(sdf), 1.0);
}
  </script>

  <!-- VERTEX SHADER -->
  <script id="vert" type="x-shader/x-vertex">
#ifdef GL_ES
precision highp float;
precision highp int;
#endif
attribute vec2 a_position;
void main(){
  gl_Position = vec4(a_position, 0.0, 1.0);
}
  </script>

  <!-- INLINE WEBGL BOOTSTRAP -->
  <script>
(function(){
  const params = new URLSearchParams(location.search);
  const variant = parseInt(params.get('var') || '0', 10);
  document.querySelectorAll('.frame__demos a').forEach(a=>{
    if (a.dataset.var == String(variant)) a.classList.add('selected');
  });

  const canvas = document.getElementById('gl');
  const dpr = Math.min(window.devicePixelRatio || 1, 2);

  const gl = canvas.getContext('webgl', {antialias:false});
  if (!gl) { alert('WebGL not supported'); return; }

  function compile(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(sh) || '(no log)';
      gl.deleteShader(sh);
      throw new Error((type===gl.VERTEX_SHADER?'VERT':'FRAG')+' compile error:\n'+log);
    }
    return sh;
  }
  function link(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
      const log = gl.getProgramInfoLog(p) || '(no log)';
      gl.deleteProgram(p);
      throw new Error('Program link error:\n'+log);
    }
    return p;
  }

  const fragUser = document.getElementById('frag').textContent;
  const vertUser = document.getElementById('vert').textContent;
  const injectedFrag = '#define VAR ' + (isFinite(variant)?variant:0) + '\n' + fragUser;

  let program;
  try{
    const vs = compile(gl.VERTEX_SHADER, vertUser);
    const fs = compile(gl.FRAGMENT_SHADER, injectedFrag);
    program = link(vs, fs);
  }catch(e){ console.error(e); alert(e.message); return; }

  gl.useProgram(program);

  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1,  -1, 1,
     1,-1,  1, 1,  -1, 1
  ]), gl.STATIC_DRAW);

  const aPos = gl.getAttribLocation(program, 'a_position');
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

  const U = n => gl.getUniformLocation(program, n);
  function set2f(n,x,y){ gl.uniform2f(U(n),x,y); }
  function set1f(n,v){ gl.uniform1f(U(n),v); }

  function resize(){
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    if (canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      gl.viewport(0,0,w,h);
      set2f('u_resolution', w, h);
      set1f('u_pixelRatio', dpr);
      draw();
    }
  }

  function updateMouse(e){
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left) * dpr;
    const y = (e.clientY - r.top) * dpr;
    set2f('u_mouse', x, y);
    draw();
  }

  window.addEventListener('pointermove', updateMouse, {passive:true});
  window.addEventListener('pointerdown', updateMouse, {passive:true});
  window.addEventListener('resize', resize);

  set2f('u_mouse', 0, 0);
  set1f('u_pixelRatio', dpr);
  resize();

  function draw(){ gl.drawArrays(gl.TRIANGLES, 0, 6); }
  draw();
  document.body.classList.remove('loading');
})();
  </script>
</body>
</html>
